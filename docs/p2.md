# 网络传输层开发文档

## 引言

本开发文档基于Rust实现一个高性能、可扩展的网络传输层（L4层），旨在为应用层提供可靠、高效的端到端数据传输服务。传输层的核心本质是“在不可靠的IP层之上，实现可靠交付与高效传输的平衡”，支持多路复用、弱网抗性，并针对不同场景进行策略优化。

文档分为两个主要部分：
- **基础部分**：实现传输层的六大核心模块（连接管理、帧封装与解封装、可靠性保障、流量控制、拥塞控制、复用与分用），形成最小可行产品（MVP），解决通用传输痛点。
- **针对在线会议的提高部分**：基于基础MVP，针对实时通信场景（如在线会议）的特定挑战（丢包、延迟抖动、多流并发）进行优化迭代，提升弱网抗性和低延迟性能。

开发依赖Rust生态：`tokio`（异步I/O）、`bytes`（缓冲处理）、`thiserror`（错误处理）。MVP目标包括自定义帧协议、基于UDP/TCP的抽象连接、心跳保活、基础可靠传输、多路复用、简单流控与拥塞控制。参考RFC（如TCP/QUIC）和开源项目，确保实现高效且可测试。

## 基础部分：六大核心模块实现

基础部分聚焦传输层的“最小核心集合”，每个模块解决一个核心问题。通过MVP实现（约800-1500行代码），先构建可靠的单流传输管道，再扩展多流支持。优先级：先实现帧封装→连接管理→可靠性保障；再实现流量控制→复用与分用；最后拥塞控制（MVP可简化）。

### 1. 连接管理
#### 解决什么问题
建立/终止端到端的逻辑通道，确保通信双方同步状态（如序号、窗口大小），避免“连接建立慢”“重连卡顿”“网络切换后断连”“状态混乱导致的丢包”。

#### 为什么这样解决
采用1-RTT握手（比TCP三次握手少1个RTT），兼顾可靠性和低延迟：客户端发SYN（初始序号+窗口），服务器回SYN-ACK，客户端发ACK完成同步。终止用FIN-ACK机制，避免数据残留。基础版基于UDP（低开销），支持心跳保活检测存活。为什么UDP？减少OS socket overhead，适合自定义协议；后期可抽象为TCP fallback。

#### 实现步骤
1. **握手建立**：发送SYN帧（携带初始序号0、窗口65535），接收SYN-ACK（确认序号+对方状态），发送ACK。使用`tokio::net::UdpSocket`绑定端口。
2. **心跳保活**：每30s发送PING帧，3次超时后关闭连接。
3. **终止连接**：发送FIN帧，等待ACK后释放资源。
4. **状态同步**：维护`TransportConnection`结构体（包含`next_seq`、`expected_seq`、`conn_id`）。

#### 参考项目
- **Quinn (Rust QUIC实现)**: 1-RTT握手和连接迁移逻辑（https://github.com/quinn-rs/quinn）。
- **Yamux (libp2p多路复用器)**: 简单握手和KeepAlive机制（https://github.com/paritytech/yamux）。

### 2. 帧封装与解封装
#### 解决什么问题
解决IP层“粘包/拆包”问题（字节流可能合并/拆分），导致应用层“消息截断”“少读/多读”“头部开销浪费带宽”。

#### 为什么这样解决
定义固定二进制帧格式（大端序，避免跨平台问题）：头部包含总长度（4B）+流ID（4B）+序列号（8B）+帧类型（1B）+接收窗口（4B）+确认序号（8B）+数据体（≤MTU 1500B）。发送方预留长度字段后填充；接收方先读长度，再读完整帧。使用`bytes`库高效处理缓冲，避免内存拷贝。为什么固定格式？简单、可扩展，支持帧类型扩展（如ACK/PING）。

#### 实现步骤
1. **帧定义**：`#[derive(Debug)] struct Frame { stream_id: u32, seq: u64, ... }`，枚举`FrameType::Data | Syn | Ack`。
2. **封装**：`encode()`方法用`BytesMut`构建，计算总长度后填充头部。
3. **解封装**：`decode(&[u8])`先读长度验证完整性，再提取字段。
4. **MTU适配**：数据超过MTU时分片（进阶），基础版假设小帧。

#### 参考项目
- **Quinn**: QUIC帧定义和`bytes`缓冲处理（高效零拷贝）。
- **Rustls**: 帧序列化和校验逻辑（https://github.com/rustls/rustls）。

### 3. 可靠性保障
#### 解决什么问题
应对IP层不可靠性（丢包/乱序），确保数据“不丢、不重、按序”，解决“数据丢失”“重复接收”“消息乱序（如IM先发后到）”。

#### 为什么这样解决
用ARQ机制：序号分配唯一ID，接收方回复ACK（确认最大连续序号），发送方超时重传（超时=RTT×1.5）。维护乱序缓冲（`BTreeMap<u64, Frame>`）按序交付。为什么序号+ACK？简单可靠，易于Rust的借用检查；超时用`tokio::time`任务轮询。基础版不处理快速重传（留给进阶）。

#### 实现步骤
1. **序号分配**：发送时`self.next_seq += 1`，记录`unacked_frames: HashMap<u64, (Frame, Instant)>`。
2. **ACK确认**：接收Data帧后发送ACK，删除已确认帧。
3. **乱序处理**：存入`out_of_order_frames`，连续序号时交付应用层。
4. **超时重传**：spawn任务每50ms检查，超时重发。

#### 参考项目
- **Quinn**: QUIC的ACK范围和重传策略。
- **WebRTC-rs**: NACK（负确认）和超时重传（https://github.com/webrtc-rs/webrtc）。

### 4. 流量控制
#### 解决什么问题
避免发送方“压垮接收方”（缓冲溢出丢包），解决“接收方处理不过来”“单个流占用所有资源”。

#### 为什么这样解决
滑动窗口机制：接收方在ACK中告知窗口大小（缓冲剩余空间），发送方仅发窗口内数据。为什么滑动窗口？动态协调速率，防止OOM；用通道`flow_control_waiter`唤醒阻塞发送。基础版全局窗口，进阶流级。

#### 实现步骤
1. **窗口更新**：接收方`update_recv_window(free_buf_size)`，在ACK中携带。
2. **发送检查**：`can_send(data_len)`计算未确认字节 ≤ 窗口。
3. **阻塞/唤醒**：窗口不足时`recv().await`等待，更新后`send(())`。
4. **零窗口探测**：窗口=0时定期发小帧（可选MVP）。

#### 参考项目
- **Yamux**: 窗口更新和BLOCK帧机制。
- **HTTP/2 (h2 crate)**: 流控实现（https://github.com/hyperium/h2）。

### 5. 拥塞控制
#### 解决什么问题
避免发送方“压垮网络”（雪崩丢包），解决“弱网下越传越卡”“跨地域速率低”“批量丢包”。

#### 为什么这样解决
慢启动+拥塞避免：初始cwnd=4帧，每ACK翻倍至阈值（64帧），后+1/RTT。丢包时cwnd/2重置。为什么基于窗口？简单估算带宽，避免盲目速率；用`token bucket`限速（进阶）。MVP简化，无BBR。

#### 实现步骤
1. **初始化**：`cwnd=4, ssthresh=64`。
2. **ACK更新**：慢启动翻倍，拥塞避免+1，唤醒发送。
3. **拥塞检测**：超时/重复ACK触发`on_congestion_detected()`降低cwnd。
4. **发送限速**：`unacked_frames.len() < cwnd`才发。

#### 参考项目
- **Quinn**: Cubic/BBR拥塞控制代码。
- **WebRTC-rs**: GCC-like带宽估计。

### 6. 复用与分用
#### 解决什么问题
支持多应用/多流并发，解决“同一连接下音视频+文件冲突”“队头阻塞”“频繁连接延迟高”。

#### 为什么这样解决
流ID标识（偶数客户端、奇数服务器），接收方根据ID分发回调。为什么流ID？独立传输无阻塞（如QUIC）；用`HashMap<u32, Pin<Box<dyn Future>>>`注册应用回调。基础版端口分用+流ID。

#### 实现步骤
1. **流创建**：`new_stream()`分配ID，插入`streams: HashMap<u32, StreamState>`。
2. **分发数据**：`dispatch_data(stream_id, data)`调用回调。
3. **注册回调**：应用层`register_stream_callback(stream_id, async_cb)`。
4. **流关闭**：支持半关闭（FIN per stream）。

#### 参考项目
- **Yamux**: 多流多路复用和流状态机。
- **Quinn**: QUIC流ID和独立可靠性。

## 针对在线会议的提高部分

在线会议场景的核心挑战是实时性（低延迟<150ms）、弱网抗性（丢包率>5%）、多流并发（音频/视频/消息/控制帧共享连接）。基于基础MVP，迭代优化：添加FEC/NACK提升丢包恢复，多流调度防阻塞，Jitter Buffer抗抖动。优先级：先FEC+多流优先级；再带宽估计+迁移。

### 1. 丢包恢复优化
#### 解决什么问题
弱网丢包（移动信号弱、Wi-Fi干扰、跨国链路）导致画面卡顿、声音断续、视频花屏（丢包率>10%时恢复延迟>200ms）。

#### 为什么这样解决
结合NACK（负确认，仅重传丢失帧）+FEC（前向纠错，发送10-20%冗余恢复丢包，无需重传）。为什么？NACK减少冗余流量，FEC适合实时（重传会卡顿）；基于基础ARQ扩展，接收方报告丢失范围（SACK-like）。

#### 实现步骤
1. **NACK机制**：接收乱序帧时，发送NACK帧（丢失序号范围），发送方立即重传。
2. **FEC编码**：用Reed-Solomon库（如`reed-solomon-erasure`）为每N帧生成K冗余帧（K=10%数据量），接收方解码恢复。
3. **阈值切换**：丢包>5%启用FEC，<2%用NACK。
4. **测试**：用`tc`模拟10%丢包，验证恢复率>95%。

#### 参考项目
- **WebRTC-rs**: NACK和FEC实现（ULPFEC模块）。
- **Mediasoup (C++/Node)**: 丢包恢复和冗余策略（https://github.com/versatica/mediasoup）。

### 2. 延迟抖动缓冲
#### 解决什么问题
RTT波动（抖动>50ms）导致音视频不同步、画面跳帧（弱网/共享网络常见）。

#### 为什么这样解决
引入Jitter Buffer：接收端缓冲2-5个帧（动态调整基于RTT统计），按序播放，丢弃过期帧（>RTT+抖动阈值）。为什么？平滑抖动而不增整体延迟；用`tokio::time`定时器管理缓冲，结合基础乱序缓冲。

#### 实现步骤
1. **缓冲区设计**：`JitterBuffer`用VecDeque存储帧，容量=2*估算RTT（ms）。
2. **动态调整**：每ACK更新RTT（`rtt = (1-α)*rtt + α*sample`，α=0.1），调整缓冲大小。
3. **帧丢弃**：入缓冲时检查延迟>阈值丢弃，低优先级流（如消息）优先丢。
4. **应用集成**：音频/视频流回调前通过缓冲输出。

#### 参考项目
- **LiveKit (Go)**: Jitter Buffer和抖动估计（https://github.com/livekit/livekit）。
- **WebRTC-rs**: 播放延迟控制。

### 3. 多流并发调度
#### 解决什么问题
高并发多流（音频+视频+协作消息）争用带宽，导致队头阻塞、音视频卡顿（单流丢包影响整体）。

#### 为什么这样解决
流优先级调度：音频（高优先）>视频（中）>消息（低），拥塞时优先高优先级流（减少cwnd分配）。结合基础多路复用，用优先级队列管理发送。为什么？避免TCP-like阻塞，QUIC-inspired独立流cwnd；用`BTreeMap<Priority, Queue<Frame>>`排序。

#### 实现步骤
1. **优先级分配**：`new_stream()`带优先级（enum Priority::High | Medium | Low）。
2. **调度发送**：`send_with_priority()`按优先级轮询，拥塞时低优先暂停。
3. **流级cwnd**：每个流独立拥塞窗口，基础全局cwnd作为上限。
4. **测试**：模拟4流并发，验证高优先流延迟<100ms。

#### 参考项目
- **Ion-SFU (Go)**: 多流调度和QoS优先级（https://github.com/ionorg/ion）。
- **Quinn**: QUIC流级拥塞控制。

### 4. 连接迁移与弱网扩展
#### 解决什么问题
网络切换（Wi-Fi→5G）中断连接，跨国高RTT（>200ms）导致传输不稳。

#### 为什么这样解决
用连接ID（而非IP+端口）标识，切换时更新路径（PATH_CHALLENGE帧验证）。结合BBR拥塞（延迟感知而非丢包）。为什么？QUIC标准，支持移动场景；基础心跳扩展为迁移探测。

#### 实现步骤
1. **ID分配**：握手时生成`conn_id: u64`，帧头携带。
2. **迁移检测**：心跳失败时发NEW_PATH帧，重绑socket。
3. **BBR集成**：替换基础拥塞，估算BtlBw（瓶颈带宽）和RTProp（传播延迟）。
4. **弱网fallback**：RTT>300ms启用FEC冗余率20%。

#### 参考项目
- **Quinn**: 连接迁移和BBR算法。
- **Mediasoup**: 弱网自适应码率。

## 总结与开发指南

基础部分构建可靠管道，解决通用痛点；提高部分针对在线会议迭代，聚焦实时弱网。总MVP代码<2000行，测试用`tc`模拟场景（丢包/延迟）。扩展时插件化（如rustls加密）。下一步：集成到会议原型，基准测试吞吐/延迟。参考整体架构：Quinn（QUIC核心）+Yamux（多路复用）+WebRTC-rs（实时优化）。