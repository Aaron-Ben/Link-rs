# 网络传输层的设计与实现

一个基于 Rust 自研的**网络传输层**，用于构建高性能，弱网抗性强，支持多路复用，可扩展的实时通信底层。

## 传输层的任务
**在不可靠的网络之上，为上层提供一个“可靠，可控，保障性能” 的数据管道。**

核心逻辑：*多路复用，可靠性，拥塞控制，流量控制，连通性管理，帧协议*等

- 提供可靠的，有序的，无差错的，基于字节流的传输服务。
- 支持多路复用，即多个应用层协议可以共享同一个传输层连接。
- 具有弱网抗性，即能够在弱网环境下正常工作，避免因为网络抖动而导致的传输失败。
- 支持可扩展性，即能够方便地添加新的功能模块，如加密，压缩等。

## MVP 目标
| 能力                   | MVP 是否要实现 | 原因             |
| -------------------- | --------- | -------------- |
| 自定义二进制帧协议            | ✔         | 节省开销、可扩展       |
| 基于 UDP 或 TCP 的抽象连接   | ✔         | 上层无需关心底层协议     |
| 心跳 & KeepAlive       | ✔         | 检测连接存活         |
| 基础可靠传输（ACK + 重传）     | ✔         | 保证控制帧可靠送达      |
| 多路复用（streams）        | ✔         | 一条连接承载多业务      |
| 简单流控（避免 OOM）         | ✔         | 防止 sender 过度推送 |
| 简单拥塞控制（速率限制）         | ✔         | 抵抗弱网；可展示工程亮点   |
| 插件式架构（之后扩展 QUIC/加密等） | ✔         | 亮点：可扩展性      |

## 传输层职责
### 传输层处理的问题：

1. **可靠性问题（丢包）**
   - 确保数据在传输过程中不丢失，通过 ACK 确认和重传机制实现。

2. **顺序问题（乱序）**
   - 确保数据在接收端按照发送顺序进行处理，通过序列号和确认机制解决。

3. **拥塞问题（带宽变化）**
   - 控制发送速率，避免网络拥塞，通过动态调整发送窗口大小实现。

4. **流量控制问题（避免压垮对端）**
   - 控制发送速率，避免对端缓冲区溢出，通过滑动窗口机制实现。

5. **多业务混合问题（多路复用）**
   - 一条连接承载多个业务流，通过流标识符进行区分和处理。

6. **链路变化问题（网络切换）**
   - 能够在网络切换时，快速切换到新的链路，避免数据丢失。

7. **弱网问题（抖动、延迟高、跨国）**
   - 能够在弱网环境下正常工作，通过重传机制和超时重传策略解决。


## 核心功能

### 自定义帧协议
* 原始的UDP/TCP是字节流
* 需要告诉对方一条消息类型，长度，流ID，是否可靠
* 扩展（ACK，PING，流量控制，优先级）

#### 参考项目

- **Yamux（libp2p multiplexer）**
- **Quinn 中的 QUIC frame 定义**
- **rustls / bytes crate 进行 high-perf buffer 处理**
  
### 多路复用
**实时系统需要多业务共享同一连接**
- 控制帧
- 音频
- 视频
- 协作消息
- 心跳

**一个连接多条流**能减少握手，头阻塞，CPU与OS socket overhead 问题

### 可靠传输
- seq + ack 机制
- 超时重传
- 每条流独立可靠性，不互相阻塞

参考：
- **QUIC reliable frame 的 ack ranges机制**
- **Reno/Cubic 重传策略**

### 不可靠流
- 允许flag 控制 “这条流不要求ACK”
- 不保seq
- 不重传
  
参考：
- **WebRTC DataChannel unordered/unreliable 模式**

### 心跳
- 每隔N秒发送一个心跳帧，检测连接是否存活
- 超时N*3 没有收到心跳帧，认为连接已断开
  
### 简单流控
- 每个流有一个接收窗口，接收端根据窗口大小调整发送速率
- 发送端根据接收端的窗口大小调整发送速率
- buffer 满后，发送BLOCK/UPDATE 帧

参考
- **yamux window undate 机制**
- HTTP/2 flow control

### 简单的拥塞控制
- 基于ack收到的速率估算链路带宽
- 当检测到丢包（没有ACK）降低速率
- 使用token bucket 算法控制发送速率
  
参考项目：
- **quinn 的拥塞控制代码**
  
## 非核心功能
| 功能                  | 推荐库         | 为什么可引用               |
| ------------------- | ----------- | -------------------- |
| 加密（TLS/DTLS）        | rustls      | 安全工程不属于传输层亮点         |
| Protobuf/MsgPack 编码 | prost / rmp | 要把精力放在传输层，而不是序列化     |
| 线程池/异步运行时           | tokio       | 不需要自研 runtime        |
| QUIC 实现             | quinn       | 如果你不想自己做迁移/握手，可以直接集成 |


## 一些扩展
| 功能                              | 作用              | 是否必须          |
| ------------------------------- | --------------- | ------------- |
| Connection Migration            | WiFi → 4G 不中断   | 飞书/Zoom 标配    |
| QoS 优先级                         | 控制帧优先 > 音频 > 视频 | 对实时会议非常重要     |
| Bandwidth Estimation (GCC-like) | 自适应码率           | WebRTC 是此领域标准 |
| FEC（前向纠错）                       | 解弱网丢包 20%       | 会议场景加分        |
| NAT Traversal (STUN)            | P2P             | 可选            |
| TURN fallback                   | 防火墙环境           | 可选            |
| SRTP / AES-GCM                  | 加密传输            | 标配            |


## 参考项目
传输层 + QUIC

quinn (Rust QUIC 实现)：高质量、可读性好
https://github.com/quinn-rs/quinn

🔵 多路复用（stream）

yamux (libp2p multiplexer)
https://github.com/paritytech/yamux

🔵 实时通信/不可靠流

webrtc-rs（数据通道、拥塞控制部分）
https://github.com/webrtc-rs/webrtc

🔵 实时音视频服务器（强参考架构）

mediasoup (C++/Node)
livekit (Go)
ion-sfu (Go)
你要研究他们的：
sender buffer 设计
nack/fec（如果你想扩展）
带宽估计（GCC-like）


---
## 聚焦于在线会议的网络场景
### 1.丢包
> 原因：移动网络信号弱，Wi-Fi干扰，国际链路，用户共享网络
> 表现：画面卡顿，声音断续，视频花屏
> 解决：NACK + 重传 + FEC
### 2.延迟抖动（RTT波动）
> 解决：Jitter Buffer + 帧丢弃策略

### 3.并发多流到这堵塞
> 多路复用 + 流调度 + 优先级丢帧

* 在线会议的传输层核心挑战是：丢包、抖动、弱网带宽不足、高并发流拥塞和跨国高 RTT。
* 因此需要通过“重传 + FEC”提高丢包恢复，“多路复用 + 流调度”解决多流争用带宽，避免队头阻塞和音视频不同步。
* 这些策略都是 HTTP/TCP 无法解决的，因此会议系统使用 UDP/QUIC + 自定义的实时传输层。